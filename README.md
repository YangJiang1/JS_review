### day1自我总结

#### JavaScript三部分

 * ECMAScript （欧洲计算机制造协会，定义语法规范）
 * BOM (browser object model 浏览器对象模型)
 * DOM (document object model 文档对象模型)

#### JavaScript数据类型

 * Number/String/Boolean/NULL/undefined/Object
 * 值类型
    * Number 
    * String (他的值是不可改变的，而当将一个已经存在的字符串赋予新值的时候，实际上在次过程中分配了一个新字符串,原有的字符串将被GC回收)
    * boolean
    * undefined
    * null(至于存在那里，这取决于解释器的具体实现)
    
 * 引用类型
    * Object(Array,Function,Date .....)
 * ES6新增
    * Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值.

####  页面的渲染过程

* 打开页面,页面标签和css进行解析

* 在解析过程中如果遇见js,则暂停html的渲染

* js执行完后,才会去渲染html页面,执行时间过长会导致页面阻塞

* 因为js是单线程的,所以我们一般把js写在底部,这也是解决页面阻塞的办法之一.

  ```javascript
  async(异步)和defer(延迟)的区别是什么?
  	首先他们两都是为了解决页面的阻塞问题.
  	async是等页面渲染完成后,立即执行.哪个js先加载,就会去执行哪个js,不保证js的执行顺序.
  	defer是等页面渲染完成后,按顺序执行js.
  
  	JavaScipt脚本阻塞问题。当前最稳妥的办法还是把Script标签放在body的底部，没有兼容性问题。不会因此产生白屏问题，没有执行顺序问题。
  ```

#### 碎片知识点

 * alert(); 会造成页面阻塞 不建议使用

 * 选择首选项->键盘快捷方式->搜索comment  修改块注释快捷键 ctrl+shift+/

 * 开启鼠标滚轮缩放 设置->搜索Mouse Wheel Zoom->开启

 * 搜狗输入法设置 中文时使用英文标点 提高开发效率

 * Ctrl+B 开关左边的导航栏

 * mynam 能组成多少个不同的字母? 1x2x3x4x5 = 120

 * 如何解决 0.1+0.2 不等于0.3

   > 因为在js中,计算0.1和0.2,计算机只认识二进制,先会把他们转换成二进制相加再将其转换为10进制,转换为2进制的过程会有无限循环,所以导致转换为10进制后不准确.
   >
   > 解决办法是(0.1 * 10 +  0.2 * 10) / 10

 * 进制转换过了一遍

### day2自我总结

#### 进制手动转换以及方法转换

 * 手动进制转换

    * 回顾了二进制,八进制,十进制,十六进制之间的手动转换.
      	* 二进制转八进制
      	* 二进制转十六进制
      	* 二进制转十进制
      	* 十进制转二进制
      	* 十进制转八进制
      	* 十进制转二进制
      	* ....等等一系列

 * JS方法进行进制转换

    * parseInt(String,radix);

       * 把string 转成 radix 进制, string要和radix进制对应,否则会是NaN  radix:2-36

         ```javascript
         parseInt("001101",2); //把二进制转换成10进制
         ```

    * toString(radix)

       * 把string(十进制)转换成目标进制 radix:2-36

         ```javascript
         var num = 123;
         num.toString(16); //10进制转换成16进制
         ```

#### 运算符

 *	算数运算符
 *	拼接运算符
 *	逻辑运算符
 *	关系运算符
 *	赋值运算符
 *	一元运算符(自增和自减)
 *	三木运算符
 *	位移运算符

>​	运算符里涉及到隐式类型转换,需要多做题目,才能掌握,在day01_js基础/typeof.md有很多类似这样的题目,没事多去刷一下,自然而言就会掌握.这里实际上比较复杂.其次就是运算符里面day02_运算符与逻辑分支/运算符.html 里面的题目还需要看一下,有的做错了,需要日后在回顾.

#### 碎片知识点

 * ASCII码 128个   0-9对应0-48   a-z对应97-122   A-Z对应65-90

 * console.log( "10" < "9") true 用"10"的"1" ascii 码和 "9"比较

 * var i = 12;  var sum = i++ + ++i + ++i * 2 + i-- + i--;   i是多少?

 * var res = (1 == 1 ? false : true); 在三木运算符写反的情况下1也不等于1

 * ```javascript
    // 这里我理解错, 我以为是取0-5
   // 实际上执行顺序 本来是0-4,每完事之后加1
   // 所以取值范围被控制在了1-5 这样操作后不可能为0
   parseInt(Math.random() * 10) % 5 + 1;
   
   //取0-100; 为什么*101因为  如果写100,它会取0-99.9999....
   parseInt(parseInt(Math.random() * 101))
   ```

 * switch() 括号里面做的运算是 === 恒等于 , 以前不知道.

### day3自我总结

