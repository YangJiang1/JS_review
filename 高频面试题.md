### 数据类型

#### JavaScript有哪些数据类型,他们的区别?	

- 基本数据类型
  - Number
  - String (他的值是不可改变的，而当将一个已经存在的字符串赋予新值的时候，实际上在次过程中分配了一个新字符串,原有的字符串将被GC回收)
  - boolean
  - undefined
  - null(至于存在那里，这取决于解释器的具体实现)
  - BigInt (ES6新增 ,使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围)
  - Symbol(ES6新增 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。)
- 引用类型
  - Object(Array,Function,Date .....)

​	基本数据类型存储在栈当中,内存由系统分配和释放.

​	引用数据类型存在堆当中,如果我们程序员不释放的话,会由垃圾回收机制帮我们释放.

#### (待看)数据类型检测的方式有哪些?

* **(1)typeof**能返回的值有Number/String/Boolean/Object/undefined/Function,**typeof**可以用来区分除了 Null类型以外的原始数据类型.

* **(2)instanceof**可以正确判断对象的类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**。

*  instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

  ```javascript
  console.log(2 instanceof Number);                    // false
  console.log(true instanceof Boolean);                // false 
  console.log('str' instanceof String);                // false 
   
  console.log([] instanceof Array);                    // true
  console.log(function(){} instanceof Function);       // true
  console.log({} instanceof Object);                   // true
  
  ```

#### 判断是否为数组的五种方法

```javascript
var arr = [];
// isAarray()
console.log(Array.isArray(arr));
// instanceof
console.log(arr instanceof Array);
// arr.__proto__ === Array.prototype;
console.log(arr.__proto__ === Array.prototype);
// Array.prototype.isPrototypeOf(arr);
console.log(Array.prototype.isPrototypeOf(arr));
// Object.prototype.toString.call(str) === '[object Array]';
console.log(Object.prototype.toString.call(arr) === '[object Array]');
```

#### NULL和undefined的区别是什么?

​	null和undefined都属于基本数据类型,

​	null和undefined是派生关系,

​	null == undefined 为true,null === undefined为false,

​	undefined代表定义**未赋值**,null代表**空对象**,

​	typeof null 为object,

​	typeof undefined 为undefined.

#### typeof null  typeof NaN的值是什么?

​	object,这是一个历史性遗留的bug.

​	typeof NaN 是Number typeof会有隐式类型转换.

#### 为什么0.1+0.2 ! == 0.3，如何让其相等 ?

​	因为在js中,计算0.1和0.2,计算机只认识二进制,先会把他们转换成二进制相加再将其转换为10进制,转换为2进制的过程会有无限循环,所以导致转换为10进制后不准确.

​	解决办法是(0.1 * 10 + 0.2 * 10) / 10

#### (带看)instanceof的操作原理以及实现

​	instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

​	实现下次写,现在不会.

####  isNaN 和 Number.isNaN 函数的区别？

* 函数isNaN会将参数转换数值为Number,任何不能被转换的数值都会返回true,因此非数值传入也会返回true,会影响NaN的判断.

* 函数Number.isNaN会首先判断传入的参数是否为数字,如果是数字在继续判断是否为NaN,不会进行数据类型的转换,这种方法判断NaN更加准确.

  ```
  isNaN('a') //true ---> Number('a') --->NaN 会隐式转换
  Number.isNaN('a')  //false  不会进行隐式转换
  ```

  一isNaN有隐式转换,Number.isNaN不会隐式转换,Number.isNaN是ES6新增的,用来解决isNaN的BUG.

#### == 操作符的强制类型转换规则？

​	对于 == 来说，如果对比双方的类型**不一样**，就会进行**隐式类型转换**。具体的总结写在了单独的markdown(typeof练习题)

#### Object.is和==与===的区别是什么?

​	==是比较值类型,会有隐式类型转换.

​	===没有隐式类型转换,如果两边的类型不一致直接返回false

​	Object和===基本一致,但是有两处不同 -0不等于+0,NaN等于NaN

```javascript
1 == '1'; -- >　1 == Number('1');   // true 会有隐式类型转换

1 === '1';  -->  // false 不会有隐士类型转换,如果不类型不相等直接返回false

//ES6之前
-0 === +0; // true;
NaN === NaN; //false 
    
//ES6新增Object.is,基本和===一致 除了以下这两种情况
Object.is(-0,+0); //false
object.is(NaN,NaN); // true;
```

